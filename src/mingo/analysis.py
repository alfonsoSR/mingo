from mingo import Database
from sqlalchemy import select, Double
from sqlalchemy.sql import func
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from typing import Any, Sequence, Literal
import pandas as pd
from dataclasses import dataclass


@dataclass
class Plot_config:
    """
    Configuration menu for plots generated by plot_dist and plot_stats

    :param title: Figure title, common for all subplots
    :param label: Label describing the property being ploted
    :param xscale: Scale to be used in the x axis
    :param yscale: Scale to be used in the y axis
    """

    title: str = ""
    label: str = ""
    xscale: Literal["linear", "log", "symlog", "logit"] = "linear"
    yscale: Literal["linear", "log", "symlog", "logit"] = "linear"


class Base:
    """
    Base class for analysis' utilities

    :param db: Database object
    """

    def __init__(self, db: Database) -> None:

        # Database objects
        self.db = db
        self.config = db.config.c
        self.plane = db.plane.c
        self.event = db.event.c
        self.hit = db.hit.c

        # Data storage
        self.dist_data: dict[str, dict[float, Any]] = {}
        self.stats_data: dict[str, pd.DataFrame] = {}

        # Plot configuration
        self.plot_config = Plot_config()

        return None

    def _make_figure(
            self,
            figsize: tuple[int, int] = (12, 6)
    ) -> tuple[Figure, Sequence[Axes]]:
        """
        Create a subplot and divide it according to the number of available
        configurations

        :param figsize: Figure dimensions in inches
        :return fig: Matplotlib figure with subplots
        :return axs: Sequence of axes associated with subplots
        """

        match len(self.dist_data.keys()):
            case 1:
                fig, axs = plt.subplots(1, 1, figsize=figsize)
                axs = [axs]
            case 2:
                fig, axs = plt.subplots(1, 2, figsize=figsize)
            case 3:
                fig, axs = plt.subplots(2, 2, figsize=figsize)
            case 4:
                fig, axs = plt.subplots(2, 2, figsize=figsize)
            case 5:
                fig, axs = plt.subplots(2, 3, figsize=figsize)
            case 6:
                fig, axs = plt.subplots(2, 3, figsize=figsize)
            case _:
                raise ValueError("Too many values for a single figure")

        return fig, axs

    def plot_distribution(self) -> Figure:
        """
        Create a set of distribution plots from the data in self.dist_data

        Plot configuration is read from the self.dist_plot dataclass

        :return fig: Matplotlib figure with distribution plots
        """

        xlim: float = 0
        ylim: float = 0

        fig, axs = self._make_figure()

        for ax, key in zip(axs, self.dist_data):

            for e, (val, count) in self.dist_data[key].items():
                ax.plot(val, count, label=f"{e:.0f} MeV")

            ax.set_xscale(self.plot_config.xscale)
            ax.set_yscale(self.plot_config.yscale)
            ax.set_title(key)
            ax.set_xlabel(self.plot_config.label)
            ax.legend()

            xlim = max(xlim, ax.get_xlim()[1])
            ylim = max(ylim, ax.get_ylim()[1])

        axs[0].set_ylabel("Number of events")
        fig.suptitle(self.plot_config.title)

        for ax in fig.get_axes():
            ax.set_xlim((None, xlim))
            ax.set_ylim((None, ylim))

        return fig

    def plot_stats(self) -> Figure:
        """
        Plot the mean, standard deviation and median of a distribution as
        function of the initial energy of the primary cosmic ray

        Plot configuration is read from `self.plot_config`

        :return fig: Figure with plots
        """

        xlim: float = 0
        ylim: float = 0

        fig, axs = self._make_figure()

        for ax, key in zip(axs, self.stats_data):
            data = self.stats_data[key]
            ax.plot(data["e_0"], data["avg"], label="Average")
            ax.fill_between(
                data["e_0"],
                data["avg"] - data["std"],
                data["avg"] + data["std"],
                label="Standard deviation", alpha=0.2
            )
            ax.scatter(
                data["e_0"], data["median"], label="Median", c="orange"
            )

            ax.set_title(key)
            ax.set_xlabel("Initial energy [MeV]")
            ax.legend()
            xlim = max(xlim, ax.get_xlim()[1])
            ylim = max(ylim, ax.get_ylim()[1])

        axs[0].set_ylabel(self.plot_config.label)
        fig.suptitle(self.plot_config.title)

        for ax in fig.get_axes():
            ax.set_xlim((None, xlim))
            ax.set_ylim((None, ylim))

        return fig

    def report_figure(self) -> Figure:
        """
        Generate a figure with pairs of distribution plots and stats tables

        :return fig: Generated figure
        """

        items = len(self.dist_data.items())
        xlim: float = 0
        ylim: float = 0

        fig = plt.figure(figsize=(10, 6 * items), layout="constrained")
        spec = fig.add_gridspec(items, 1)

        for idx, key in enumerate(self.dist_data):

            dist = self.dist_data[key]
            stats = self.stats_data[key]

            _fig = fig.add_subfigure(spec[idx, 0])
            _spec = _fig.add_gridspec(1, 2)
            ax_plot = _fig.add_subplot(_spec[0, 0])
            ax_table = _fig.add_subplot(_spec[0, 1])

            # Plot distribution
            for e, (val, count) in dist.items():
                ax_plot.plot(val, count, label=f"{e:.0f} MeV")

            ax_plot.set_xscale(self.plot_config.xscale)
            ax_plot.set_yscale(self.plot_config.yscale)
            ax_plot.set_xlabel(self.plot_config.label)
            ax_plot.set_ylabel("Number of events")
            ax_plot.set_title(key)
            ax_plot.legend()

            xlim = max(xlim, ax_plot.get_xlim()[1])
            ylim = max(ylim, ax_plot.get_ylim()[1])

            # Add table
            ax_table.axis("off")
            ax_table.table(
                cellText=stats.values,
                colLabels=stats.columns.tolist(),
                loc="center"
            )

        fig.suptitle(self.plot_config.title)

        # fig.suptitle(self.report_config.title)
        for ax in fig.get_axes():
            if ax.axison:
                ax.set_xlim((None, xlim))
                ax.set_ylim((None, ylim))

        return fig

    def distribution(self, config_id: int, config_key: str) -> None:
        """
        Base method for distribution data retrievers

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
        """

        NotImplemented

    def stats(self, config_id: int, config_key: str) -> None:
        """
        Base method for stats data retrievers

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
        """

        NotImplemented

    def __call__(self, config_id: int, config_key: str) -> None:
        """
        Executes the distribution and stats methods in one call

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
        """

        self.distribution(config_id, config_key)
        self.stats(config_id, config_key)

        return None


class Hit_distribution(Base):
    """
    Relationship between the number of hits per event and the initial energy
    of the primary cosmic ray

    :param db: Database object
    """

    def __init__(self, db: Database) -> None:

        super().__init__(db)

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = "Number of hits per event"
        self.plot_config.title = (
            "Distribution of hits per event as a function of initial energy"
        )

        return None

    def stats(self, config_id: int, config_key: str) -> None:
        """
        Statistical properties of the distribution of hits per event as a
        function of the initial energy of the primary cosmic ray

        Results are saved as items of the dictionary self.stats_data with
        key 'config_key'

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
       """

        stmt = select(
            self.event.e_0,
            func.avg(self.event.n_hits, type_=Double),
            func.median(self.event.n_hits).over(self.event.e_0),
            func.stddev_samp(self.event.n_hits, type_=Double)
        )
        stmt = stmt.where(self.event.fk_config == config_id)
        stmt = stmt.group_by(self.event.e_0)

        with self.db.engine.connect() as conn:

            stats = pd.DataFrame(
                [
                    [e_0, avg, median, std]
                    for e_0, avg, median, std in conn.execute(stmt)
                ], columns=["e_0", "avg", "median", "std"]
            )

        stats["avg / std"] = stats["avg"] / stats["std"]

        self.stats_data[config_key] = stats.round(2)

        return None

    def distribution(self, config_id: int, config_key: str) -> None:
        """
        Distribution of hits per event as a function of the initial energy of
        the primary cosmic ray

        Results are saved as items of the dictionary self.dist_data with key
        'config_key'

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
        """
        with self.db.engine.connect() as conn:

            hits = {
                energy: np.array([
                    [hit, count] for hit, count in conn.execute(
                        select(self.event.n_hits, func.count(self.event.e_0))
                        .where(self.event.fk_config == config_id)
                        .where(self.event.e_0 == energy)
                        .group_by(self.event.n_hits)
                    )
                ]).swapaxes(0, 1) for energy, in conn.execute(
                    select(self.event.e_0)
                    .where(self.event.fk_config == config_id)
                    .distinct()
                    .order_by(self.event.e_0)
                )
            }

        self.dist_data[config_key] = hits

        return None


class Shower_depth(Base):
    """
    Relationship between the average depth of the electron shower
    produced by a primary cosmic ray and its initial energy

    :param db: Database object
    """

    def __init__(self, db: Database) -> None:

        super().__init__(db)

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = "Average shower depth [mm]"
        self.plot_config.title = (
            "Average shower depth as a function of initial energy"
        )

        return None

    def distribution(
            self, config_id: int, config_key: str, R: float = 5
    ) -> None:
        """
        Distribution of average shower depth values as a function of the
        initial energy of the primary cosmic ray

        Results are saved as items of the dictionary self.dist_data with key
        'config_key'

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
        :param R: Round factor
        """

        tmp = (
            select(
                self.event.e_0.label("e_0"),
                (func.round(func.avg(self.hit.z) / R) * R).label("avg_z")
            )
            .select_from(
                self.db.event.join(
                    self.db.hit, self.event.id == self.hit.fk_event
                )
            )
            .where(self.event.fk_config == config_id)
            .group_by(self.hit.fk_event)
            .alias("tmp")
        )

        with self.db.engine.connect() as conn:

            result = {
                energy: np.array([
                    [avg_z, count] for avg_z, count in conn.execute(
                        select(tmp.c.avg_z, func.count(tmp.c.avg_z))
                        .where(tmp.c.e_0 == energy)
                        .group_by(tmp.c.avg_z)
                    )
                ]).swapaxes(0, 1) for energy, in conn.execute(
                    select(self.event.e_0)
                    .where(self.event.fk_config == config_id)
                    .distinct()
                    .order_by(self.event.e_0)
                )
            }

        self.dist_data[config_key] = result

        return None

    def stats(self, config_id: int, config_key: str) -> None:
        """
        Statistical properties of the distribution of average shower depth
        values as a function of the initial energy of the primary cosmic ray

        Results are saved as items of the dictionary self.stats_data with
        key 'config_key'

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
       """

        stmt = (
            select(self.hit.fk_event, func.avg(self.hit.z).label("avg_z"))
            .group_by(self.hit.fk_event)
            .alias("stmt")
        )

        with self.db.engine.connect() as conn:

            result = pd.DataFrame(
                [
                    [e_0, avg, median, std]
                    for e_0, avg, median, std in conn.execute(
                        select(
                            self.event.e_0,
                            func.avg(stmt.c.avg_z, type_=Double),
                            func.median(stmt.c.avg_z).over(self.event.e_0),
                            func.stddev_samp(stmt.c.avg_z, type_=Double)
                        )
                        .select_from(self.db.event.join(stmt))
                        .where(self.event.fk_config == config_id)
                        .group_by(self.event.e_0)
                    )
                ], columns=["e_0", "avg", "median", "std"]
            )

        result["avg / std"] = result["avg"] / result["std"]

        self.stats_data[config_key] = result.round(2)

        return None


class Plane_hits(Base):
    """
    Relationship between the number of hits per event on a given plane and
    the initial energy of the primary cosmic ray

    :param db: Database object
    :param plane: Plane number (First is 1 last is 4)
    """

    def __init__(self, db: Database, plane: int) -> None:

        super().__init__(db)

        self.plane_number = plane

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = f"Number of hits in plane {self.plane_number}"
        self.plot_config.title = (
            "Number of hits per event as a function of initial energy: "
            f"Plane {self.plane_number}"
        )

        return None

    def distribution(self, config_id: int, config_key: str) -> None:
        """
        Distribution of hits per event on a given plane as a function of the
        initial energy of the primary cosmic ray

        Results are saved as items of the dictionary self.dist_data with key
        'config_key'

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
        """

        self.dist_data[config_key] = {}

        with self.db.engine.connect() as conn:

            energies = conn.execute(
                select(self.event.e_0)
                .where(self.event.fk_config == config_id)
                .distinct()
                .order_by(self.event.e_0)
            )

            for energy, in energies:

                tmp = (
                    select((func.count(self.hit.id)).label("hits"))
                    .select_from(
                        self.db.event.join(
                            self.db.hit, self.event.id == self.hit.fk_event
                        )
                    )
                    .where(
                        self.event.fk_config == config_id,
                        self.event.e_0 == energy,
                        self.hit.plane == self.plane_number
                    )
                    .group_by(self.event.id)
                    .alias("tmp")
                )

                self.dist_data[config_key][energy] = np.array([
                    [val, count] for val, count in conn.execute(
                        select(tmp.c.hits, func.count(tmp.c.hits))
                        .group_by(tmp.c.hits)
                    )
                ]).swapaxes(0, 1)

        return None

    def stats(self, config_id: int, config_key: str) -> None:
        """
        Statistical properties of the number of hits per event on a given
        plane as a function of the initial energy of the primary cosmic ray

        Results are saved as items of the dictionary self.stats_data with
        key 'config_key'

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
       """

        tmp = (
            select(
                self.event.e_0.label("e_0"),
                func.count(self.hit.id).label("hits")
            )
            .select_from(
                self.db.event.join(
                    self.db.hit, self.event.id == self.hit.fk_event
                )
            )
            .where(
                self.event.fk_config == config_id,
                self.hit.plane == self.plane_number
            )
            .group_by(self.event.id)
        )

        with self.db.engine.connect() as conn:

            result = pd.DataFrame(
                [
                    [e_0, avg, median, std]
                    for e_0, avg, median, std in conn.execute(
                        select(
                            tmp.c.e_0,
                            func.avg(tmp.c.hits, type_=Double),
                            func.median(tmp.c.hits).over(tmp.c.e_0),
                            func.stddev_samp(tmp.c.hits, type_=Double)
                        )
                        .group_by(tmp.c.e_0)
                    )
                ], columns=["e_0", "avg", "median", "std"]
            )

        result["avg / std"] = result["avg"] / result["std"]

        self.stats_data[config_key] = result.round(2)

        return None


class Scattering(Base):
    """
    Relationship between the average distance between detected particles and
    the center of a given active plane and the initial energy of the primary
    cosmic ray

    :param db: Database object
    :param plane: Plane number (First is 1, last is 4)
    """

    def __init__(self, db: Database, plane: int) -> None:

        super().__init__(db)

        self.plane_number = plane

        # Plot configuration
        self.plot_config.xscale = "linear"
        self.plot_config.yscale = "linear"
        self.plot_config.label = (
            f"Average distance to center of plane {self.plane_number} [mm]"
        )
        self.plot_config.title = (
            "Hit scattering as a function of initial energy: "
            f"Plane {self.plane_number}"
        )

        return None

    def distribution(
            self, config_id: int, config_key: str, R: float = 0.1) -> None:
        """
        Distribution of the average distance to the center of the chosen
        active plane as a function of the initial energy of the primary
        cosmic ray

        Results are saved as items of the dictionary self.dist_data with key
        'config_key'

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
        :param R: Round factor
        """
        self.dist_data[config_key] = {}

        with self.db.engine.connect() as conn:

            energies = conn.execute(
                select(self.event.e_0)
                .where(self.event.fk_config == config_id)
                .distinct()
                .order_by(self.event.e_0)
            )

            for energy, in energies:

                tmp = (
                    select(
                        self.event.id.label("id"),
                        self.event.e_0.label("e_0"),
                        (func.round(
                            func.avg(
                                func.sqrt(
                                    self.hit.x * self.hit.x +
                                    self.hit.y * self.hit.y
                                )
                            ) * R
                        ) / R).label("avg_R")
                    )
                    .select_from(
                        self.db.event.join(
                            self.db.hit, self.event.id == self.hit.fk_event
                        )
                    )
                    .where(
                        self.event.fk_config == config_id,
                        self.event.e_0 == energy,
                        self.hit.plane == self.plane_number
                    )
                    .group_by(self.hit.fk_event)
                    .alias("tmp")
                )

                self.dist_data[config_key][energy] = np.array([
                    [avg, count] for avg, count in conn.execute(
                        select(
                            tmp.c.avg_R,
                            func.count(tmp.c.avg_R).label("count")
                        )
                        .group_by(tmp.c.avg_R)
                    )
                ]).swapaxes(0, 1)

        return None

    def stats(self, config_id: int, config_key: str) -> None:
        """
        Statistical properties of the distribution of the average distance
        to the center of the chosen active plane as a function of the
        initial energy of the primary cosmic ray

        Results are saved as items of the dictionary self.stats_data with key
        'config_key'

        :param config_id: ID of desired detector configuration
        :param config_key: Title for associated plots
        """

        tmp = (
            select(
                self.hit.fk_event,
                func.avg(func.sqrt(
                    self.hit.x * self.hit.x + self.hit.y * self.hit.y
                )).label("avg_R")
            )
            .group_by(self.hit.fk_event)
            .alias("tmp")
        )

        with self.db.engine.connect() as conn:

            result = pd.DataFrame(
                [
                    [e_0, avg, median, std]
                    for e_0, avg, median, std in conn.execute(
                        select(
                            self.event.e_0,
                            func.avg(tmp.c.avg_R, type_=Double),
                            func.median(tmp.c.avg_R).over(self.event.e_0),
                            func.stddev_samp(tmp.c.avg_R, type_=Double)
                        )
                        .select_from(self.db.event.join(tmp))
                        .where(self.event.fk_config == config_id)
                        .group_by(self.event.e_0)
                    )
                ], columns=["e_0", "avg", "median", "std"]
            )

        result["avg / std"] = result["avg"] / result["std"]

        self.stats_data[config_key] = result.round(2)

        return None
